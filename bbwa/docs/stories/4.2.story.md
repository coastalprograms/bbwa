# Story 4.2: Real-Time Site Check-in

## Status

Ready for Dev

## Story

**As a worker or visitor**, I want to check in to a job site using a QR code and my email so that the system knows I am on-site.

## Acceptance Criteria

1. A check-in page allows a worker to input their email address.
2. The page uses geolocation to detect the worker's current job site.
3. The system verifies the worker's email exists in the `workers` table.
4. The system verifies the worker's white card is valid and not expired.
5. On success, a row is created in `site_attendances` with worker_id, job_site_id (from geolocation), and timestamp.
6. A success message is displayed.
7. If invalid/expired, access is blocked and a clear message is shown (see 4.3 for compliance alert details).
8. Loading and error UI implemented; accessible and mobile-first.
9. CSRF and input validation enforced.

## Tasks / Subtasks

- [ ] Route & UI (AC: 1, 6, 8, 9)
  - [ ] Page: `apps/web/src/app/check-in/page.tsx` (Server Component rendering a Client form)
  - [ ] Client Component: `apps/web/src/app/check-in/CheckInForm.tsx`
  - [ ] Loading/Error UI: `apps/web/src/app/check-in/(loading|error).tsx`
  - [ ] Geolocation via browser API; fallback to manual site selection if denied
  - [ ] Show success/failure messages with aria-live
- [ ] Server action & validation (AC: 2–5, 7, 9)
  - [ ] File: `apps/web/src/app/check-in/actions.ts`
  - [ ] CSRF issuance and validation
  - [ ] Reverse-geocode or nearest-site lookup based on provided coords
  - [ ] Verify worker exists; verify certification status not expired
  - [ ] Insert into `site_attendances` on success
  - [ ] Return structured errors for UI
- [ ] Data and utilities
  - [ ] Utility to compute nearest site: `apps/web/src/lib/geo.ts` (Haversine)
  - [ ] Interface types for payloads and results

## Dev Notes

### Relevant Architecture References

- PRD Epic 4 Story 4.2. [Source: `docs/prd.md#story-4.2-real-time-site-check-in`]
- Security & RLS; prepared queries. [Source: `docs/architecture.md#architectural-and-design-patterns`]
- Data models (workers, certifications, site_attendances, job_sites). [Source: `docs/architecture.md#data-models`]

### Implementation Outline

- Client obtains `navigator.geolocation` (with permission prompt). Send coords along with email.
- Server computes nearest site from `job_sites(lat,lng,radius_m)` or reverse-geocodes if available; choose within radius else return error.
- Verify worker exists and certification validity (white card not expired today).
- If valid: insert `site_attendances(worker_id, job_site_id, checked_in_at now())` and return success.
- If invalid: return error; UI displays block notice. 4.3 handles alerting.
- CSRF: cookie token + hidden input; honeypot to curb spam.
- Accessibility: focus management; keyboard-friendly and mobile-first.

### Example Snippets

```tsx
// apps/web/src/app/check-in/page.tsx
import CheckInForm from './CheckInForm'

export const metadata = { title: 'Site Check-in' }

export default function CheckInPage() {
  return (
    <main className="mx-auto max-w-md px-4 sm:px-6 lg:px-8">
      <h1 className="mt-8 text-2xl font-semibold">Check in</h1>
      <p className="mt-2 text-gray-700">Enter your email and share your location to check in to the nearest site.</p>
      <CheckInForm />
    </main>
  )
}
```

```tsx
// apps/web/src/app/check-in/CheckInForm.tsx
'use client'
import { useEffect, useRef, useState } from 'react'
import { checkIn } from './actions'

export default function CheckInForm() {
  const [email, setEmail] = useState('')
  const [coords, setCoords] = useState<{ lat: number; lng: number } | null>(null)
  const [csrfToken, setCsrfToken] = useState('')
  const [status, setStatus] = useState<'idle'|'locating'|'submitting'>('idle')
  const [success, setSuccess] = useState('')
  const [errors, setErrors] = useState<Record<string, string>>({})
  const errorRef = useRef<HTMLDivElement | null>(null)

  useEffect(() => {
    const token = document.cookie.split('; ').find((c) => c.startsWith('csrf_token='))?.split('=')[1] || ''
    setCsrfToken(token)
  }, [])

  useEffect(() => { if (Object.keys(errors).length && errorRef.current) errorRef.current.focus() }, [errors])

  async function getLocation() {
    setStatus('locating')
    return new Promise<void>((resolve) => {
      navigator.geolocation.getCurrentPosition(
        (pos) => { setCoords({ lat: pos.coords.latitude, lng: pos.coords.longitude }); resolve(); setStatus('idle') },
        () => { setErrors({ form: 'Location permission denied. Select site manually or retry.' }); resolve(); setStatus('idle') }
      )
    })
  }

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setErrors({}); setSuccess(''); setStatus('submitting')
    const res = await checkIn({ email, coords, csrfToken, website: '' })
    setStatus('idle')
    if (res?.errors) return setErrors(res.errors)
    if (res?.success) setSuccess('Checked in successfully. Stay safe!')
  }

  return (
    <form onSubmit={onSubmit} className="mt-6 space-y-4">
      <div aria-live="polite" className="sr-only">{success}</div>
      {Object.keys(errors).length > 0 && (
        <div ref={errorRef} tabIndex={-1} className="rounded border border-red-300 bg-red-50 p-3 text-red-700">{errors.form || 'Please correct the highlighted fields below.'}</div>
      )}
      <label className="block">
        <span className="sr-only">Email</span>
        <input aria-label="Email" type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" required className="w-full border p-2" />
      </label>
      <div className="flex items-center gap-3">
        <button type="button" onClick={getLocation} className="rounded border px-3 py-2">
          {status === 'locating' ? 'Locating…' : 'Share location'}
        </button>
        <span className="text-sm text-gray-600">{coords ? `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}` : 'No location yet'}</span>
      </div>
      {/* Honeypot */}
      <input type="text" name="website" tabIndex={-1} autoComplete="off" className="hidden" aria-hidden="true" />
      <input type="hidden" name="csrfToken" value={csrfToken} />
      <button disabled={status==='submitting'} type="submit" className="bg-black px-4 py-2 text-white">{status==='submitting' ? 'Checking in…' : 'Check in'}</button>
      {success && <p className="text-green-700">{success}</p>}
    </form>
  )
}
```

```ts
// apps/web/src/app/check-in/actions.ts
'use server'
import { cookies } from 'next/headers'
import { createClient } from '@/src/lib/supabase/server'

export async function checkIn({ email, coords, csrfToken, website }: { email: string; coords: { lat: number; lng: number } | null; csrfToken: string; website?: string }) {
  const cookieToken = cookies().get('csrf_token')?.value
  if (!cookieToken || cookieToken !== csrfToken) return { errors: { form: 'Invalid session' } }
  if (website && website.trim().length > 0) return { errors: { form: 'Spam detected' } }

  const supabase = createClient()

  // Find worker
  const { data: worker } = await supabase.from('workers').select('id').eq('email', email.trim().toLowerCase()).maybeSingle()
  if (!worker) return { errors: { form: 'Worker not found. Please complete induction first.' } }

  // Check certification validity
  const { data: cert } = await supabase.from('certifications').select('id, expiry_date').eq('worker_id', worker.id).order('updated_at', { ascending: false }).maybeSingle()
  const today = new Date().toISOString().slice(0, 10)
  if (!cert || (cert.expiry_date && cert.expiry_date < today)) {
    return { errors: { form: 'Sorry, your white card is out of date. Do not enter the site. Please fill out a new form to upload your new white card.' } }
  }

  // Compute nearest site (MVP: choose first active site or by coords if provided)
  let siteId: string | null = null
  if (coords) {
    const { data: sites } = await supabase.from('job_sites').select('id, lat, lng, radius_m').eq('active', true)
    // very simple nearest within radius
    const within = (s: any) => {
      const R = 6371000
      const toRad = (deg: number) => (deg * Math.PI) / 180
      const dLat = toRad(s.lat - coords.lat)
      const dLng = toRad(s.lng - coords.lng)
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(coords.lat))*Math.cos(toRad(s.lat))*Math.sin(dLng/2)**2
      const d = 2 * R * Math.asin(Math.sqrt(a))
      return d <= (s.radius_m || 500)
    }
    siteId = sites?.find((s) => within(s))?.id || null
  }
  if (!siteId) return { errors: { form: 'No active site found near your location. Please contact your supervisor.' } }

  const { error } = await supabase.from('site_attendances').insert({ worker_id: worker.id, job_site_id: siteId })
  if (error) return { errors: { form: 'Unable to check in at this time.' } }

  return { success: true }
}

## Testing Requirements

- Location allowed → nearest site found → success row in `site_attendances`
- Location denied → error prompts manual resolution; no insert
- Worker not found → error; expired certification → error message matches PRD wording
- TypeScript/ESLint pass; mobile-first and accessible; CSRF enforced

## Technical Constraints

- Server Components by default; Client for geolocation & form
- No secrets exposed client-side; RLS enforced; public data reads only
- Prepared queries and robust error handling; timing-safe CSRF check

## Assumptions

- `job_sites` table contains `lat,lng,radius_m,active`; RLS allows public read
- Certification rows include `expiry_date`; timezone handling uses Australian context when applicable

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-15 | 0.1 | Initial draft for Epic 4 Story 4.2 with geolocation, nearest site, and attendance insert. | SM |
| 2025-08-17 | 0.2 | Status updated to Ready for Dev after standards review (App Router, TS strict, Tailwind, accessibility, SEO, loading/error). | SM |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List
